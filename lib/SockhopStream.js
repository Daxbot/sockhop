
const { v4:uuidv4 } = require("uuid");
const { EventEmitter } = require("events");

const SockhopError = require("./SockhopError.js");

/**
 * A SockhopStreamRequest object
 *
 * This is used (primarially internally) to wrap requests to the peer
 * connection, and for them to generate and return SockhopResponses.
 *
 * On the "requester-side" this object is never actually touched by the
 * user, it is auto-generated by the `.request(...)` method. On the
 * "responder-side", a copy of this object is emitted by the `request` event,
 * which the responder can use to de-payload the request via the `.type` and `.data`
 * attributes.
 *
 *
 * @ignore
 */
class SockhopStreamRequest {
    /**
     * Constructor
     *
     * @param {object} [opts] an object containing configuration options
     * @param {string} [opts.uuid] the identifier of this request/response pair (default is autogenerated)
     * @param {*} [opts.data={}] the data of this request
     * @param {string} [opts.type] the type (class-name) of the data (default is autogenerated)
     *
     */
    constructor({ uuid, data={}, type }={}) {
        this.uuid = uuid || uuidv4();
        this.data = data;
        if ( !type ) {
            this.type = data.constructor.name;
        } else {
            this.type = type;
        }
    }

    /**
     * Parse a serialized SockhopStreamRequest
     *
     * @static
     * @param {object} obj - the serialized request object
     * @returns {SockhopStreamRequest}
     */
    static parse(obj) {
        return new this(obj);
    }

    /**
     * Create a request from a new data payload
     *
     * @static
     * @param {*} data - the object to be included as a payload
     * @returns {SockhopStreamRequest}
     */
    static from_data(data) {
        return new this({ data });
    }
}

/**
 * A SockhopStreamPacket object
 *
 * These are used internally to pass back responses to requests
 *
 *
 * @ignore
 */
class SockhopStreamPacket {
    /**
     * Constructor
     *
     * @param {object} [opts] an object containing configuration options
     * @param {string} [opts.uuid] the identifier of this request/response pair (default is autogenerated)
     * @param {*} [opts.data={}] the data of this request
     * @param {string} [opts.type] the type (class-name) of the data (default is autogenerated)
     */
    constructor({ uuid, data={}, type=null, last=false }) {
        this.uuid = uuid || uuidv4();
        this.data = data;
        if ( !type ) {
            this.type = data.constructor.name;
        } else {
            this.type = type;
        }
        this.last = last;
    }

    /**
     * Custom serializer method for JSON.stringify()
     *
     * Included to make sure we don't try to serialize
     * the `._sockhop` reference, and that the `._data`
     * attribute gets serialized to the `data` key
     *
     * @private
     * @returns {object}
     */
    toJSON() {
        return {
            uuid : this.uuid,
            type : this.type,
            data : this.data,
            last : this.last
        };
    }

    /**
     * Parse a serialized SockhopStreamPacket
     *
     * @static
     * @param {object} obj - the serialized response object
     * @returns {SockhopStreamRequest}
     */
    static parse(obj) {
        return new this(obj);
    }


    /**
     * Create a response packet from a data object
     *
     * @static
     * @param {*} data - data payload
     * @param {string} uuid - the uuid for this packet
     * @param {boolean} [last=false] - flag indicating this is the last packet in the stream
     * @returns {SockhopStreamRequest}
     */
    static for_data(data, uuid, last=false) {
        return new this({
            uuid : uuid,
            data : data,
            last : last
        });
    }
}

/**
 * A packet of data has arrived
 * @event SockhopReadableStream#data
 * @param {*} data - the serialized payload from the responder
 * @param {string} type - The type (class name) of the data
 *
 *
 * @ignore
 */
/**
 * The stream has ended
 * @event SockhopReadableStream#end
 * @param {?SockhopError} [err=undefined] if the stream was ended due to an error, it will show up here
 *
 *
 * @ignore
 */
/**
 * A SockhopReadableStream object
 *
 * This is used by the requester to catch all the response packets that
 * the responder is sending back, it functions vaguely like an ReadableStream
 * from the core library, but is not yet fully featured for that.
 *
 * @fires SockhopReadableStream#data
 * @fires SockhopReadableStream#end
 * @extends EventEmitter
 *
 *
 * @ignore
 */
class SockhopReadableStream extends EventEmitter {
    /**
     * Constructor
     *
     * @param {object} [opts] an object containing configuration options
     * @param {string} [opts.uuid] the identifier of this request/response pair (default is autogenerated)
     */
    constructor({ uuid }) {
        super();
        this.uuid = uuid || uuidv4();
        this._ended = false;
    }

    /**
     * Flag indicating if the stream has ended
     *
     * @type {boolean}
     */
    get ended() {
        return this._ended;
    }

    /**
     * Create a response readable stream for use by requester
     *
     * @static
     * @param {SockhopStreamRequest} req
     * @returns {SockhopResponseStream}
     */
    static from_request(req) {
        return new this({
            uuid : req.uuid
        });
    }

    /**
     * Handle received packets
     *
     * @param {SockhopStreamPacket} pkt
     * @fires SockhopReadableStream#data
     * @fires SockhopReadableStream#end
     */
    receive_packet(pkt) {
        if ( this.ended ) return;
        this.emit("data", pkt.data, pkt.type);
        if (pkt.last) this.end();
    }

    /**
     * End this stream
     *
     * @param {?SockhopError} [err=undefined] optional error for why the stream was ended, no error means graceful ending
     */
    end(err) {
        if ( this._ended ) return;
        this._ended = true;
        this.emit("end", err);
    }

    /**
     * @typedef {object} ResponsePacketPayload
     * @property {*} data
     * @property {string} type
     */
    /**
     * Wait for the next packet to arrive, then close the stream
     *
     * @returns {Promise<ResponsePacketPayload>}
     */
    next() {
        return new Promise(resolve => {
            this.once("data",(data,type) => {
                resolve({ data, type });
                this.end();
            });
        });
    }

    /**
     * Wait for all packets
     *
     * @returns {Promise<ResponsePacketPayload[]>}
     */
    all() {
        return new Promise(resolve => {
            let pkts = [];
            this.on("data", (data, type) => {
                pkts.push({ data, type });
            });
            this.once("end",() => {
                resolve(pkts);
            });
        });
    }
}

/**
 * A SockhopWriteableStream object
 *
 * This is used by the responder to stream out all the response packets to
 * the requester, it functions vaguely like an WriteableStream
 * from the core library, but is not yet fully featured for that.
 *
 *
 *
 * @ignore
 */
class SockhopWriteableStream {
    /**
     * Constructor
     *
     * @param {object} [opts] an object containing configuration options
     * @param {string} [opts.uuid] the identifier of this request/response pair (default is autogenerated)
     * @param {SockhopClient|SockhopSession} sockhop A reference to the sockhop object which will be used to return the finished response
     */
    constructor({ uuid, sockhop }) {
        this.uuid = uuid || uuidv4();
        this._sockhop = sockhop;
    }

    /**
     * Create a response object from a received request object
     *
     * @static
     * @param {object} req_obj - the serialized request object
     * @param {SockhopClient|SockhopSession} sockhop - a reference to the sockhop object used to send back response packets
     * @returns {SockhopResponseStream}
     */
    static from_request(req_obj, sockhop) {
        return new this({
            uuid : req_obj.uuid,
            sockhop : sockhop
        });
    }

    /**
     * Send a reponse packet back to the peer connection, closing the stream
     *
     * @param {*} data - The payload to send back to the requester
     * @returns {Promise} resolves on message send
     * @throws {SockhopError}
     */
    send(data) {
        const pkt = SockhopStreamPacket.for_data(data, this.uuid, true);
        return this._send(pkt).then((v) => {
            this._end_called = true;
            return v;
        });
    }

    /**
     * Send this response back to the peer connection, keeping the stream open
     *
     * @param {*} data - The payload to send back to the requester
     * @returns {Promise} resolves on message send
     * @throws {SockhopError}
     */
    write(data) {
        const pkt = SockhopStreamPacket.for_data(data, this.uuid);
        return this._send(pkt);
    }

    /**
     * Closing the stream, notifying the requester
     *
     * @returns {Promise} resolves on message send
     * @throws {SockhopError}
     */
    end() {
        return this.send({});
    }

    /**
     * Send this response back to the peer connection
     *
     * Note, this only works if this response was constructed by the "responder" NOT the "requester",
     * and it can only be called exactly once.
     *
     * @private
     * @param {SockhopStreamPacket} pkt
     * @returns {Promise} resolves on message send
     * @throws {SockhopError}
     */
    _send(pkt) {
        if ( !this._sockhop ) return Promise.reject(new SockhopError("Response packet cannot be sent back to responder", "ERR_RESPONSE_SEND"));
        if ( this._end_called ) return Promise.reject(new SockhopError("Response packet cannot be sent after end", "ERR_RESPONSE_SEND"));
        return this._sockhop._send_message({ type:pkt.constructor.name, data:pkt });
    }
}

module.exports = exports = {
    SockhopStreamRequest,
    SockhopStreamPacket,
    SockhopReadableStream,
    SockhopWriteableStream
};
