## Classes

<dl>
<dt><a href="#ObjectBuffer">ObjectBuffer</a> ⇐ <code>EventEmitter</code></dt>
<dd><p>Object Buffer</p>
<p>de/serialize objects to/from a Buffer</p>
<p>Automatically reassembles fragmented buffers (useful when the buffer passes through
a socket, for example, and is received in pieces) and gives you your object back</p>
</dd>
<dt><a href="#SockhopClient">SockhopClient</a> ⇐ <code>EventEmitter</code></dt>
<dd><p>Wrapped TCP client</p>
</dd>
<dt><a href="#SockhopError">SockhopError</a> ⇐ <code>Error</code></dt>
<dd><p>Custom sockhop errors</p>
<p>Error types, should only change with major versions</p>
<ul>
<li>ERR_MULTICONNECT : attempting to call connect while a socket is already connecting</li>
<li>ERR_SOCKET_DESTROYED : attempting to interact with a destroyed socket</li>
<li>ERR_REMOTE_CALLBACK_TYPE : attempting to use remote callbacks with wrong message types, or not a callback function</li>
<li>ERR_REQUEST_TYPE : attempting to use requests with wrong message types</li>
<li>ERR_NO_SOCKET : attempting to send a message with no socket</li>
<li>ERR_BAD_DATA : attempting to send a message with no data payload</li>
<li>ERR_OBJECTBUFFER_BAD_BUFFER : attempting to do a buffer operation with a non-buffer</li>
<li>ERR_OBJECTBUFFER_BAD_BUFFER_DATA : attempting to do a buffer operation with bad data in the buffer</li>
<li>ERR_OBJECTBUFFER_BAD_OBJECT : attempting to do an object operation with a non-serializable object</li>
<li>ERR_RESPONSE_TIMEOUT : the response timed out</li>
<li>ERR_RESPONSE_SEND : the response could not be sent</li>
</ul>
</dd>
<dt><a href="#SockhopPing">SockhopPing</a></dt>
<dd><p>TCP Ping</p>
<p>Used internally when .ping() is called</p>
</dd>
<dt><a href="#SockhopPong">SockhopPong</a></dt>
<dd><p>TCP Ping reply</p>
<p>Used internally when .ping() is replied</p>
</dd>
<dt><a href="#SockhopRequest">SockhopRequest</a></dt>
<dd><p>A SockhopRequest object</p>
<p>This is used (primarially internally) to wrap requests to the peer
connection, and for them to generate and return SockhopResponses.</p>
<p>On the &quot;requester-side&quot; this object is never actually touched by the
user, it is auto-generated by the <code>.request(...)</code> method. On the
&quot;responder-side&quot;, a copy of this object is emitted by the <code>request</code> event,
which the responder can use to de-payload the request via the <code>.type</code> and <code>.data</code>
attributes.</p>
</dd>
<dt><a href="#SockhopResponsePacket">SockhopResponsePacket</a></dt>
<dd><p>A SockhopResponsePacket object</p>
<p>These are used internally to pass back responses to requests</p>
</dd>
<dt><a href="#SockhopResponseReadableStream">SockhopResponseReadableStream</a> ⇐ <code>EventEmitter</code></dt>
<dd><p>A SockhopResponseReadableStream object</p>
<p>This is used by the requester to catch all the response packets that
the responder is sending back, it functions vaguely like an ReadableStream
from the core library, but is not yet fully featured for that.</p>
</dd>
<dt><a href="#SockhopResponseWriteableStream">SockhopResponseWriteableStream</a></dt>
<dd><p>A SockhopResponseWriteableStream object</p>
<p>This is used by the responder to stream out all the response packets to
the requester, it functions vaguely like an WriteableStream
from the core library, but is not yet fully featured for that.</p>
</dd>
<dt><a href="#SockhopServer">SockhopServer</a> ⇐ <code>EventEmitter</code></dt>
<dd><p>Wrapped TCP server</p>
<p>When data is received by the server, the received Buffer is concatenated with previously
received Buffers until a delimiter (usually &quot;\n&quot;) is received.  The composite Buffer is then treated
like a JSON string and converted to an object, which is triggers a &quot;receive&quot; event.
If the client is a SockhopClient, it will further wrap sent data in metadata that describes the type -
this allows you to pass custom objects (prototypes) across the wire, and the other end will know
it has received your Widget, or Foo, or whatever.  Plain objects, strings, etc. are also similarly labelled.
The resulting receive event has a &quot;meta&quot; parameter; meta.type will list the object type.</p>
<p>Of course, if your client is not a SockhopClient, you don&#39;t want this wrapping/unwrapping behavior
and you might want a different delimiter for JSON.  Both these parameters are configurable in the
constructor options.</p>
</dd>
<dt><a href="#SockhopSession">SockhopSession</a> ⇐ <code>EventEmitter</code></dt>
<dd><p>Base class wrapper for server-side sockets</p>
<p>When a new connection is received by the server, the server will wrap
that socket with an instance of this (or child of this) class -- configurable
with the <code>session_type</code> option in the server&#39;s constructor. This class
allows for arbitrary user-data to be assigned to the clients (for example,
authentication state information) without having to abuse the underlying
net.Socket object.</p>
<p>This class does almost nothing, apart from holding internal references to
the net.Socket and SockhopServer instances, and is really intended to be
extended. As such, there are several &#39;virtual&#39; methods included here,
which users are encouraged to implement for their specific application.</p>
<p>Sessions are the preferred way for users to interact with client connections,
in that users should write child classes which inhert from this base class to
interact with the net.Socket instance, and then have their applications call
the session methods, rather than calling socket methods directly. For instance,
users are discouraged from directly calling <code>socket.end()</code> to terminate
clients connection from the server. Rather, users should call <code>session.kill()</code>.</p>
</dd>
<dt><a href="#TimedMap">TimedMap</a></dt>
<dd><p>A timed map object</p>
<p>This is a wrapper around a map, which keeps a timer going to automatically
remove values that have been present for too long.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#ResponsePacketPayload">ResponsePacketPayload</a> : <code>object</code></dt>
<dd></dd>
</dl>

<a name="ObjectBuffer"></a>

## ObjectBuffer ⇐ <code>EventEmitter</code>
Object Buffer

de/serialize objects to/from a Buffer

Automatically reassembles fragmented buffers (useful when the buffer passes through
a socket, for example, and is received in pieces) and gives you your object back

**Kind**: global class  
**Extends**: <code>EventEmitter</code>  

* [ObjectBuffer](#ObjectBuffer) ⇐ <code>EventEmitter</code>
    * [new ObjectBuffer(opts)](#new_ObjectBuffer_new)
    * [.buf2obj(buffer)](#ObjectBuffer+buf2obj) ⇒ <code>Array</code>
    * [.obj2buf(object, buffer)](#ObjectBuffer+obj2buf)

<a name="new_ObjectBuffer_new"></a>

### new ObjectBuffer(opts)
Constructs a new ObjectBuffer


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| opts | <code>object</code> |  | the options |
| [opts.terminator] | <code>string</code> \| <code>array</code> | <code>&quot;\&quot;\\n\&quot;&quot;</code> | the terminator to signal the end of a JSON object. If an array is given, the first element is a receive (buf2obj) terminator and the second is the transmit (obj2buf) element |
| [opts.allow_non_objects] | <code>boolean</code> | <code>false</code> | allow non objects in buf2obj (will be passed through as Strings) |

<a name="ObjectBuffer+buf2obj"></a>

### objectBuffer.buf2obj(buffer) ⇒ <code>Array</code>
buf2obj

Convert a Buffer into one or more objects

**Kind**: instance method of [<code>ObjectBuffer</code>](#ObjectBuffer)  
**Returns**: <code>Array</code> - found the objects we found  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>Buffer</code> | the buffer to read (we may modify or store it!) |

<a name="ObjectBuffer+obj2buf"></a>

### objectBuffer.obj2buf(object, buffer)
obj2buf

Convert an Object to a Buffer

**Kind**: instance method of [<code>ObjectBuffer</code>](#ObjectBuffer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object</code> | the object to convert |
| buffer | <code>Buffer</code> | the buffer representing that object |

<a name="SockhopClient"></a>

## SockhopClient ⇐ <code>EventEmitter</code>
Wrapped TCP client

**Kind**: global class  
**Extends**: <code>EventEmitter</code>  
**Emits**: [<code>connect</code>](#SockhopClient+event_connect), [<code>disconnect</code>](#SockhopClient+event_disconnect), [<code>receive</code>](#SockhopClient+event_receive), [<code>request</code>](#SockhopClient+event_request), <code>event:SockhopError</code>  

* [SockhopClient](#SockhopClient) ⇐ <code>EventEmitter</code>
    * [new SockhopClient([opts])](#new_SockhopClient_new)
    * [.connected](#SockhopClient+connected) : <code>boolean</code>
    * [.auto_reconnect_active](#SockhopClient+auto_reconnect_active) : <code>boolean</code>
    * ~~[.auto_reconnect](#SockhopClient+auto_reconnect)~~
    * [.start()](#SockhopClient+start) ⇒ <code>Promise.&lt;this&gt;</code>
    * [.connect(config)](#SockhopClient+connect) ⇒ <code>Promise.&lt;this&gt;</code>
    * [.get_bound_address()](#SockhopClient+get_bound_address) ⇒ <code>string</code>
    * [.send(object, [rcallback])](#SockhopClient+send) ⇒ <code>Promise</code>
    * [.request(object, config)](#SockhopClient+request) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
    * [.ping(delay)](#SockhopClient+ping)
    * [.disconnect()](#SockhopClient+disconnect) ⇒ <code>Promise</code>
    * ["connect" (sock)](#SockhopClient+event_connect)
    * ["receive" (object, meta)](#SockhopClient+event_receive)
    * ["request" (req, res)](#SockhopClient+event_request)
    * ["disconnect" (sock)](#SockhopClient+event_disconnect)

<a name="new_SockhopClient_new"></a>

### new SockhopClient([opts])
Constructs a new SockhopClient


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [opts] | <code>object</code> |  | an object containing configuration options |
| [opts.path] | <code>string</code> |  | the path for a Unix domain socket.  If used, this will override the address and port values. |
| [opts.address] | <code>string</code> | <code>&quot;\&quot;127.0.0.1\&quot;&quot;</code> | the IP address to bind to |
| [opts.port] | <code>number</code> | <code>50000</code> | the TCP port to use |
| [opts.ssl] | <code>boolean</code> | <code>false</code> | use tls |
| [opts.ssl_options] | <code>object</code> | <code>{}</code> | options to pass to the tls socket constructor, see `tls.connect` for details, note, if any options are provided, the `opts.ssl` flag is overriden as true |
| [opts.auto_reconnect_interval] | <code>number</code> | <code>2000</code> | the auto reconnection interval, in ms. |
| opts.peer_type | <code>string</code> |  | the type of client to expect.  Defaults to "Sockhop" and expects wrapped JSON objects.  Set to "json" to expect and deliver raw JSON objects |
| [opts.terminator] | <code>string</code> \| <code>array</code> | <code>&quot;\&quot;\\n\&quot;&quot;</code> | the JSON object delimiter.  Passed directly to the ObjectBuffer constructor. |
| [opts.allow_non_objects] | <code>boolean</code> | <code>false</code> | allow non objects to be received and transmitted. Passed directly to the ObjectBuffer constructor. |
| [opts.response_timeout] | <code>number</code> |  | the length of time in ms that this map should hold values by default |
| [opts.connect_timeout] | <code>number</code> | <code>5000</code> | the length of time in ms to try to connect before timing out |

<a name="SockhopClient+connected"></a>

### sockhopClient.connected : <code>boolean</code>
Is the socket connected?

**Kind**: instance property of [<code>SockhopClient</code>](#SockhopClient)  
<a name="SockhopClient+auto_reconnect_active"></a>

### sockhopClient.auto\_reconnect\_active : <code>boolean</code>
Is auto-reconnection active?

**Kind**: instance property of [<code>SockhopClient</code>](#SockhopClient)  
<a name="SockhopClient+auto_reconnect"></a>

### ~~sockhopClient.auto\_reconnect~~
***Deprecated***

auto_reconnect setter

**Kind**: instance property of [<code>SockhopClient</code>](#SockhopClient)  
**Throws**:

- <code>Error</code> 'The .auto_reconnect setter has been deprecated in v2'


| Param | Type | Description |
| --- | --- | --- |
| auto_reconnect | <code>boolean</code> | the desired auto_reconnect setting |

<a name="SockhopClient+start"></a>

### sockhopClient.start() ⇒ <code>Promise.&lt;this&gt;</code>
Start a persistant connection to the server

Note, this method will only return once a valid connection has been achieved (and so could hang indefinitely).
This will also start an auto-reconnection timer which will attempt to keep this connection live. Use `.disconnect()`
to stop.

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
**Returns**: <code>Promise.&lt;this&gt;</code> - The socket is connected  
<a name="SockhopClient+connect"></a>

### sockhopClient.connect(config) ⇒ <code>Promise.&lt;this&gt;</code>
Connect to the server

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
**Returns**: <code>Promise.&lt;this&gt;</code> - if connection is successful  
**Throws**:

- <code>Error</code> if connection fails or times out


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| config | <code>object</code> |  |  |
| [config.auto_reconnect] | <code>boolean</code> | <code>false</code> | should the connection attempt to reconnect after the initial connection succeeds? |

<a name="SockhopClient+get_bound_address"></a>

### sockhopClient.get\_bound\_address() ⇒ <code>string</code>
Get bound address

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
**Returns**: <code>string</code> - the IP address we are bound to  
<a name="SockhopClient+send"></a>

### sockhopClient.send(object, [rcallback]) ⇒ <code>Promise</code>
Send

Send an object to the server

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type | Description |
| --- | --- | --- |
| object | <code>object</code> | to be sent over the wire |
| [rcallback] | <code>function</code> | Callback when remote side calls meta.callback (see receive event) - this is basically a remote Promise |

<a name="SockhopClient+request"></a>

### sockhopClient.request(object, config) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
Make a request

Send a request to the server

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type | Description |
| --- | --- | --- |
| object | <code>object</code> | to be sent over the wire |
| config | <code>object</code> |  |
| [config.timeout] | <code>number</code> |  |

<a name="SockhopClient+ping"></a>

### sockhopClient.ping(delay)
Ping

Send ping, detect timeouts.  If we have 4 timeouts in a row, we kill the connection and emit a 'disconnect' event.
You can then call .connect() again to reconnect.

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| delay | <code>number</code> | <code>0</code> | in ms (0 disables ping) |

<a name="SockhopClient+disconnect"></a>

### sockhopClient.disconnect() ⇒ <code>Promise</code>
disconnect

Disconnect the socket (send FIN)
Pinging will also be turned off... if you want to keep pinging, you will need to call .ping() again after you connect again

**Kind**: instance method of [<code>SockhopClient</code>](#SockhopClient)  
<a name="SockhopClient+event_connect"></a>

### "connect" (sock)
connect event

**Kind**: event emitted by [<code>SockhopClient</code>](#SockhopClient)  

| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the socket that just connected |

<a name="SockhopClient+event_receive"></a>

### "receive" (object, meta)
receive object event

We have successfully received an object from the server

**Kind**: event emitted by [<code>SockhopClient</code>](#SockhopClient)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>object</code> | the received object |
| meta | <code>object</code> | metadata |
| meta.type | <code>string</code> | the received object constructor ("Object", "String", "Widget", etc) |

<a name="SockhopClient+event_request"></a>

### "request" (req, res)
receive request event

We have successfully received a request object from the client

**Kind**: event emitted by [<code>SockhopClient</code>](#SockhopClient)  

| Param | Type |
| --- | --- |
| req | [<code>SockhopRequest</code>](#SockhopRequest) | 
| res | [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream) | 

<a name="SockhopClient+event_disconnect"></a>

### "disconnect" (sock)
disconnect event

**Kind**: event emitted by [<code>SockhopClient</code>](#SockhopClient)  

| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the socket that just disconnected |

<a name="SockhopError"></a>

## SockhopError ⇐ <code>Error</code>
Custom sockhop errors

Error types, should only change with major versions
  - ERR_MULTICONNECT : attempting to call connect while a socket is already connecting
  - ERR_SOCKET_DESTROYED : attempting to interact with a destroyed socket
  - ERR_REMOTE_CALLBACK_TYPE : attempting to use remote callbacks with wrong message types, or not a callback function
  - ERR_REQUEST_TYPE : attempting to use requests with wrong message types
  - ERR_NO_SOCKET : attempting to send a message with no socket
  - ERR_BAD_DATA : attempting to send a message with no data payload
  - ERR_OBJECTBUFFER_BAD_BUFFER : attempting to do a buffer operation with a non-buffer
  - ERR_OBJECTBUFFER_BAD_BUFFER_DATA : attempting to do a buffer operation with bad data in the buffer
  - ERR_OBJECTBUFFER_BAD_OBJECT : attempting to do an object operation with a non-serializable object
  - ERR_RESPONSE_TIMEOUT : the response timed out
  - ERR_RESPONSE_SEND : the response could not be sent

**Kind**: global class  
**Extends**: <code>Error</code>  
<a name="new_SockhopError_new"></a>

### new SockhopError(message, code)
Constructs a new SockhopError


| Param | Type | Description |
| --- | --- | --- |
| message | <code>string</code> | A message string describing the error |
| code | <code>string</code> | A standardized code for filtering error types |

<a name="SockhopPing"></a>

## SockhopPing
TCP Ping

Used internally when .ping() is called

**Kind**: global class  

* [SockhopPing](#SockhopPing)
    * [.unanswered()](#SockhopPing+unanswered) ⇒ <code>boolean</code>
    * [.conclude_with_pong(pong)](#SockhopPing+conclude_with_pong)

<a name="SockhopPing+unanswered"></a>

### sockhopPing.unanswered() ⇒ <code>boolean</code>
Unanswered

Is this ping Unanswered?

**Kind**: instance method of [<code>SockhopPing</code>](#SockhopPing)  
<a name="SockhopPing+conclude_with_pong"></a>

### sockhopPing.conclude\_with\_pong(pong)
Conclude a ping

Sets the returned, finished values

**Kind**: instance method of [<code>SockhopPing</code>](#SockhopPing)  

| Param | Type | Description |
| --- | --- | --- |
| pong | [<code>SockhopPong</code>](#SockhopPong) | the pong (ping reply) that is finishing this ping |

<a name="SockhopPong"></a>

## SockhopPong
TCP Ping reply

Used internally when .ping() is replied

**Kind**: global class  
<a name="SockhopRequest"></a>

## SockhopRequest
A SockhopRequest object

This is used (primarially internally) to wrap requests to the peer
connection, and for them to generate and return SockhopResponses.

On the "requester-side" this object is never actually touched by the
user, it is auto-generated by the `.request(...)` method. On the
"responder-side", a copy of this object is emitted by the `request` event,
which the responder can use to de-payload the request via the `.type` and `.data`
attributes.

**Kind**: global class  

* [SockhopRequest](#SockhopRequest)
    * [new SockhopRequest([opts])](#new_SockhopRequest_new)
    * [.parse(obj)](#SockhopRequest.parse) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
    * [.from_data(data)](#SockhopRequest.from_data) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)

<a name="new_SockhopRequest_new"></a>

### new SockhopRequest([opts])
Constructor


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [opts] | <code>object</code> |  | an object containing configuration options |
| [opts.uuid] | <code>string</code> |  | the identifier of this request/response pair (default is autogenerated) |
| [opts.data] | <code>\*</code> | <code>{}</code> | the data of this request |
| [opts.type] | <code>string</code> |  | the type (class-name) of the data (default is autogenerated) |

<a name="SockhopRequest.parse"></a>

### SockhopRequest.parse(obj) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
Parse a serialized SockhopRequest

**Kind**: static method of [<code>SockhopRequest</code>](#SockhopRequest)  

| Param | Type | Description |
| --- | --- | --- |
| obj | <code>object</code> | the serialized request object |

<a name="SockhopRequest.from_data"></a>

### SockhopRequest.from\_data(data) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
Create a request from a new data payload

**Kind**: static method of [<code>SockhopRequest</code>](#SockhopRequest)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>\*</code> | the object to be included as a payload |

<a name="SockhopResponsePacket"></a>

## SockhopResponsePacket
A SockhopResponsePacket object

These are used internally to pass back responses to requests

**Kind**: global class  

* [SockhopResponsePacket](#SockhopResponsePacket)
    * [new SockhopResponsePacket([opts])](#new_SockhopResponsePacket_new)
    * [.parse(obj)](#SockhopResponsePacket.parse) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
    * [.for_data(data, uuid, [last])](#SockhopResponsePacket.for_data) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)

<a name="new_SockhopResponsePacket_new"></a>

### new SockhopResponsePacket([opts])
Constructor


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [opts] | <code>object</code> |  | an object containing configuration options |
| [opts.uuid] | <code>string</code> |  | the identifier of this request/response pair (default is autogenerated) |
| [opts.data] | <code>\*</code> | <code>{}</code> | the data of this request |
| [opts.type] | <code>string</code> |  | the type (class-name) of the data (default is autogenerated) |

<a name="SockhopResponsePacket.parse"></a>

### SockhopResponsePacket.parse(obj) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
Parse a serialized SockhopResponsePacket

**Kind**: static method of [<code>SockhopResponsePacket</code>](#SockhopResponsePacket)  

| Param | Type | Description |
| --- | --- | --- |
| obj | <code>object</code> | the serialized response object |

<a name="SockhopResponsePacket.for_data"></a>

### SockhopResponsePacket.for\_data(data, uuid, [last]) ⇒ [<code>SockhopRequest</code>](#SockhopRequest)
Create a response packet from a data object

**Kind**: static method of [<code>SockhopResponsePacket</code>](#SockhopResponsePacket)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| data | <code>\*</code> |  | data payload |
| uuid | <code>string</code> |  | the uuid for this packet |
| [last] | <code>boolean</code> | <code>false</code> | flag indicating this is the last packet in the stream |

<a name="SockhopResponseReadableStream"></a>

## SockhopResponseReadableStream ⇐ <code>EventEmitter</code>
A SockhopResponseReadableStream object

This is used by the requester to catch all the response packets that
the responder is sending back, it functions vaguely like an ReadableStream
from the core library, but is not yet fully featured for that.

**Kind**: global class  
**Extends**: <code>EventEmitter</code>  
**Emits**: [<code>data</code>](#SockhopResponseReadableStream+event_data), [<code>end</code>](#SockhopResponseReadableStream+event_end)  

* [SockhopResponseReadableStream](#SockhopResponseReadableStream) ⇐ <code>EventEmitter</code>
    * [new SockhopResponseReadableStream([opts])](#new_SockhopResponseReadableStream_new)
    * _instance_
        * [.ended](#SockhopResponseReadableStream+ended) : <code>boolean</code>
        * [.receive_packet(pkt)](#SockhopResponseReadableStream+receive_packet)
        * [.end([err])](#SockhopResponseReadableStream+end)
        * [.next()](#SockhopResponseReadableStream+next) ⇒ [<code>Promise.&lt;ResponsePacketPayload&gt;</code>](#ResponsePacketPayload)
        * [.all()](#SockhopResponseReadableStream+all) ⇒ <code>Promise.&lt;Array.&lt;ResponsePacketPayload&gt;&gt;</code>
        * ["data" (data, type)](#SockhopResponseReadableStream+event_data)
        * ["end" ([err])](#SockhopResponseReadableStream+event_end)
    * _static_
        * [.from_request(req)](#SockhopResponseReadableStream.from_request) ⇒ <code>SockhopResponseStream</code>

<a name="new_SockhopResponseReadableStream_new"></a>

### new SockhopResponseReadableStream([opts])
Constructor


| Param | Type | Description |
| --- | --- | --- |
| [opts] | <code>object</code> | an object containing configuration options |
| [opts.uuid] | <code>string</code> | the identifier of this request/response pair (default is autogenerated) |

<a name="SockhopResponseReadableStream+ended"></a>

### sockhopResponseReadableStream.ended : <code>boolean</code>
Flag indicating if the stream has ended

**Kind**: instance property of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  
<a name="SockhopResponseReadableStream+receive_packet"></a>

### sockhopResponseReadableStream.receive\_packet(pkt)
Handle received packets

**Kind**: instance method of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  
**Emits**: [<code>data</code>](#SockhopResponseReadableStream+event_data), [<code>end</code>](#SockhopResponseReadableStream+event_end)  

| Param | Type |
| --- | --- |
| pkt | [<code>SockhopResponsePacket</code>](#SockhopResponsePacket) | 

<a name="SockhopResponseReadableStream+end"></a>

### sockhopResponseReadableStream.end([err])
End this stream

**Kind**: instance method of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  

| Param | Type | Description |
| --- | --- | --- |
| [err] | [<code>SockhopError</code>](#SockhopError) | optional error for why the stream was ended, no error means graceful ending |

<a name="SockhopResponseReadableStream+next"></a>

### sockhopResponseReadableStream.next() ⇒ [<code>Promise.&lt;ResponsePacketPayload&gt;</code>](#ResponsePacketPayload)
Wait for the next packet to arrive, then close the stream

**Kind**: instance method of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  
<a name="SockhopResponseReadableStream+all"></a>

### sockhopResponseReadableStream.all() ⇒ <code>Promise.&lt;Array.&lt;ResponsePacketPayload&gt;&gt;</code>
Wait for all packets

**Kind**: instance method of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  
<a name="SockhopResponseReadableStream+event_data"></a>

### "data" (data, type)
A packet of data has arrived

**Kind**: event emitted by [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>\*</code> | the serialized payload from the responder |
| type | <code>string</code> | The type (class name) of the data |

<a name="SockhopResponseReadableStream+event_end"></a>

### "end" ([err])
The stream has ended

**Kind**: event emitted by [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  

| Param | Type | Description |
| --- | --- | --- |
| [err] | [<code>SockhopError</code>](#SockhopError) | if the stream was ended due to an error, it will show up here |

<a name="SockhopResponseReadableStream.from_request"></a>

### SockhopResponseReadableStream.from\_request(req) ⇒ <code>SockhopResponseStream</code>
Create a response readable stream for use by requester

**Kind**: static method of [<code>SockhopResponseReadableStream</code>](#SockhopResponseReadableStream)  

| Param | Type |
| --- | --- |
| req | [<code>SockhopRequest</code>](#SockhopRequest) | 

<a name="SockhopResponseWriteableStream"></a>

## SockhopResponseWriteableStream
A SockhopResponseWriteableStream object

This is used by the responder to stream out all the response packets to
the requester, it functions vaguely like an WriteableStream
from the core library, but is not yet fully featured for that.

**Kind**: global class  

* [SockhopResponseWriteableStream](#SockhopResponseWriteableStream)
    * [new SockhopResponseWriteableStream([opts], sockhop)](#new_SockhopResponseWriteableStream_new)
    * _instance_
        * [.send(data)](#SockhopResponseWriteableStream+send) ⇒ <code>Promise</code>
        * [.write(data)](#SockhopResponseWriteableStream+write) ⇒ <code>Promise</code>
        * [.end()](#SockhopResponseWriteableStream+end) ⇒ <code>Promise</code>
    * _static_
        * [.from_request(req_obj, sockhop)](#SockhopResponseWriteableStream.from_request) ⇒ <code>SockhopResponseStream</code>

<a name="new_SockhopResponseWriteableStream_new"></a>

### new SockhopResponseWriteableStream([opts], sockhop)
Constructor


| Param | Type | Description |
| --- | --- | --- |
| [opts] | <code>object</code> | an object containing configuration options |
| [opts.uuid] | <code>string</code> | the identifier of this request/response pair (default is autogenerated) |
| sockhop | [<code>SockhopClient</code>](#SockhopClient) \| [<code>SockhopSession</code>](#SockhopSession) | A reference to the sockhop object which will be used to return the finished response |

<a name="SockhopResponseWriteableStream+send"></a>

### sockhopResponseWriteableStream.send(data) ⇒ <code>Promise</code>
Send a reponse packet back to the peer connection, closing the stream

**Kind**: instance method of [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream)  
**Returns**: <code>Promise</code> - resolves on message send  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type | Description |
| --- | --- | --- |
| data | <code>\*</code> | The payload to send back to the requester |

<a name="SockhopResponseWriteableStream+write"></a>

### sockhopResponseWriteableStream.write(data) ⇒ <code>Promise</code>
Send this response back to the peer connection, keeping the stream open

**Kind**: instance method of [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream)  
**Returns**: <code>Promise</code> - resolves on message send  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type | Description |
| --- | --- | --- |
| data | <code>\*</code> | The payload to send back to the requester |

<a name="SockhopResponseWriteableStream+end"></a>

### sockhopResponseWriteableStream.end() ⇒ <code>Promise</code>
Closing the stream, notifying the requester

**Kind**: instance method of [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream)  
**Returns**: <code>Promise</code> - resolves on message send  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 

<a name="SockhopResponseWriteableStream.from_request"></a>

### SockhopResponseWriteableStream.from\_request(req_obj, sockhop) ⇒ <code>SockhopResponseStream</code>
Create a response object from a received request object

**Kind**: static method of [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream)  

| Param | Type | Description |
| --- | --- | --- |
| req_obj | <code>object</code> | the serialized request object |
| sockhop | [<code>SockhopClient</code>](#SockhopClient) \| [<code>SockhopSession</code>](#SockhopSession) | a reference to the sockhop object used to send back response packets |

<a name="SockhopServer"></a>

## SockhopServer ⇐ <code>EventEmitter</code>
Wrapped TCP server

When data is received by the server, the received Buffer is concatenated with previously
received Buffers until a delimiter (usually "\n") is received.  The composite Buffer is then treated
like a JSON string and converted to an object, which is triggers a "receive" event.
If the client is a SockhopClient, it will further wrap sent data in metadata that describes the type -
this allows you to pass custom objects (prototypes) across the wire, and the other end will know
it has received your Widget, or Foo, or whatever.  Plain objects, strings, etc. are also similarly labelled.
The resulting receive event has a "meta" parameter; meta.type will list the object type.

Of course, if your client is not a SockhopClient, you don't want this wrapping/unwrapping behavior
and you might want a different delimiter for JSON.  Both these parameters are configurable in the
constructor options.

**Kind**: global class  
**Extends**: <code>EventEmitter</code>  
**Emits**: [<code>connect</code>](#SockhopServer+event_connect), [<code>disconnect</code>](#SockhopServer+event_disconnect), [<code>receive</code>](#SockhopServer+event_receive), [<code>request</code>](#SockhopServer+event_request), <code>event:SockhopError</code>  

* [SockhopServer](#SockhopServer) ⇐ <code>EventEmitter</code>
    * [new SockhopServer([opts])](#new_SockhopServer_new)
    * [.sockets](#SockhopServer+sockets) : <code>Array.&lt;net.Socket&gt;</code>
    * [.sessions](#SockhopServer+sessions) : [<code>Array.&lt;SockhopSession&gt;</code>](#SockhopSession)
    * [.emit_async()](#SockhopServer+emit_async)
    * [.ping(delay)](#SockhopServer+ping)
    * [.listen()](#SockhopServer+listen) ⇒ <code>Promise.&lt;net.server&gt;</code>
    * [.get_bound_address()](#SockhopServer+get_bound_address) ⇒ <code>string</code>
    * [.send(socket, object, [callback])](#SockhopServer+send) ⇒ <code>Promise</code>
    * [.request(sock, object, config)](#SockhopServer+request) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
    * [.sendall(object)](#SockhopServer+sendall) ⇒ <code>Promise</code>
    * [.kill_socket(sock)](#SockhopServer+kill_socket) ⇒ <code>Promise</code>
    * [.disconnect()](#SockhopServer+disconnect) ⇒ <code>Promise</code>
    * [.close()](#SockhopServer+close) ⇒ <code>Promise</code>
    * ["connect" (sock, session)](#SockhopServer+event_connect)
    * ["receive" (object, meta)](#SockhopServer+event_receive)
    * ["request" (req, res, meta)](#SockhopServer+event_request)
    * ["disconnect" (sock, session)](#SockhopServer+event_disconnect)

<a name="new_SockhopServer_new"></a>

### new SockhopServer([opts])
Constructs a new SockhopServer


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [opts] | <code>object</code> |  | an object containing configuration options |
| [opts.path] | <code>string</code> |  | the path for a Unix domain socket.  If used, this will override the address and port values. |
| [opts.address] | <code>string</code> | <code>&quot;\&quot;127.0.0.1\&quot;&quot;</code> | the IP address to bind to |
| [opts.port] | <code>number</code> | <code>50000</code> | the TCP port to use |
| [opts.auto_reconnect_interval] | <code>number</code> | <code>2000</code> | the auto reconnection interval, in ms. |
| [opts.terminator] | <code>string</code> \| <code>array</code> | <code>&quot;\&quot;\\n\&quot;&quot;</code> | the JSON object delimiter.  Passed directly to the ObjectBuffer constructor. |
| [opts.allow_non_objects] | <code>boolean</code> | <code>false</code> | allow non objects to be received and transmitted. Passed directly to the ObjectBuffer constructor. |
| [opts.peer_type] | <code>string</code> | <code>&quot;\&quot;SockhopClient\&quot;&quot;</code> | the type of client to expect.  Defaults to "SockhopClient" and expects wrapped JSON objects.  Set to "json" to expect and deliver raw JSON objects |
| [opts.session_type] | <code>Object</code> | <code>SockhopSession</code> | the identifier for a SockhopSession class (or inhereted class) |
| [opts.response_timeout] | <code>number</code> |  | the length of time in ms that this map should hold values by default |

<a name="SockhopServer+sockets"></a>

### sockhopServer.sockets : <code>Array.&lt;net.Socket&gt;</code>
Socket getter

**Kind**: instance property of [<code>SockhopServer</code>](#SockhopServer)  
<a name="SockhopServer+sessions"></a>

### sockhopServer.sessions : [<code>Array.&lt;SockhopSession&gt;</code>](#SockhopSession)
Session getter

**Kind**: instance property of [<code>SockhopServer</code>](#SockhopServer)  
<a name="SockhopServer+emit_async"></a>

### sockhopServer.emit\_async()
Emit async

We end up with odd event loops sometimes, e.g. if an on("disconnect") calls .sendall(), another "disconnect" will be emitted.
This functon emits evens asynchronously and breaks the chain
//HACK  -- THIS IS A HACKY FIX -- //HACK

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
<a name="SockhopServer+ping"></a>

### sockhopServer.ping(delay)
Ping

Ping all clients, detect timeouts. Only works if connected to a SockhopClient.

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| delay | <code>number</code> | <code>0</code> | in ms (0 disables ping) |

<a name="SockhopServer+listen"></a>

### sockhopServer.listen() ⇒ <code>Promise.&lt;net.server&gt;</code>
Listen

Bind and wait for incoming connections

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
<a name="SockhopServer+get_bound_address"></a>

### sockhopServer.get\_bound\_address() ⇒ <code>string</code>
Get bound address

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
**Returns**: <code>string</code> - the IP address we are bound to  
<a name="SockhopServer+send"></a>

### sockhopServer.send(socket, object, [callback]) ⇒ <code>Promise</code>
Send

Send an object to one clients

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
**Throws**:

- SockhopError


| Param | Type | Description |
| --- | --- | --- |
| socket | <code>net.socket</code> | on which to send it |
| object | <code>object</code> | that we want to send |
| [callback] | <code>function</code> | Callback when remote side calls meta.done (see receive event) - this is basically a remote Promise |

<a name="SockhopServer+request"></a>

### sockhopServer.request(sock, object, config) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
Make a request

Send a request to the server

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.socket</code> |  |
| object | <code>object</code> | to be sent over the wire |
| config | <code>object</code> |  |
| [config.timeout] | <code>number</code> |  |

<a name="SockhopServer+sendall"></a>

### sockhopServer.sendall(object) ⇒ <code>Promise</code>
Sendall

Send an object to all clients

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>object</code> | to send to all connected clients |

<a name="SockhopServer+kill_socket"></a>

### sockhopServer.kill\_socket(sock) ⇒ <code>Promise</code>
Stops a client connection

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the client socket to kill |

<a name="SockhopServer+disconnect"></a>

### sockhopServer.disconnect() ⇒ <code>Promise</code>
Disconnect

Disconnect all clients
Does not close the server - use close() for that

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
**Returns**: <code>Promise</code> - resolves when all sockets are killed  
<a name="SockhopServer+close"></a>

### sockhopServer.close() ⇒ <code>Promise</code>
Close

Disconnects any clients and closes the server

**Kind**: instance method of [<code>SockhopServer</code>](#SockhopServer)  
**Returns**: <code>Promise</code> - resovles when all sockets are killed and the server closed  
<a name="SockhopServer+event_connect"></a>

### "connect" (sock, session)
connect event

**Kind**: event emitted by [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the socket that just connected |
| session | [<code>SockhopSession</code>](#SockhopSession) | the session of the socket |

<a name="SockhopServer+event_receive"></a>

### "receive" (object, meta)
receive object event

We have successfully received an object from the client

**Kind**: event emitted by [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>object</code> | the received object |
| meta | <code>object</code> | metadata |
| meta.type | <code>string</code> | the received object constructor ("Object", "String", "Widget", etc) |
| meta.socket | <code>net.Socket</code> | the socket that sent us this object |
| meta.session | [<code>SockhopSession</code>](#SockhopSession) | the session of the socket |
| [meta.callback] | <code>function</code> | the callback function, if the client is requesting a callback. Pass an object you want returned to the client |

<a name="SockhopServer+event_request"></a>

### "request" (req, res, meta)
receive request event

We have successfully received a request object from the client

**Kind**: event emitted by [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| req | [<code>SockhopRequest</code>](#SockhopRequest) |  |
| res | [<code>SockhopResponseWriteableStream</code>](#SockhopResponseWriteableStream) |  |
| meta | <code>object</code> | metadata |
| meta.socket | <code>net.Socket</code> | the socket that sent us this object |
| meta.session | [<code>SockhopSession</code>](#SockhopSession) | the session of the socket |

<a name="SockhopServer+event_disconnect"></a>

### "disconnect" (sock, session)
disconnect event

**Kind**: event emitted by [<code>SockhopServer</code>](#SockhopServer)  

| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the socket that just disconnected |
| session | [<code>SockhopSession</code>](#SockhopSession) | the session of the socket |

<a name="SockhopSession"></a>

## SockhopSession ⇐ <code>EventEmitter</code>
Base class wrapper for server-side sockets

When a new connection is received by the server, the server will wrap
that socket with an instance of this (or child of this) class -- configurable
with the `session_type` option in the server's constructor. This class
allows for arbitrary user-data to be assigned to the clients (for example,
authentication state information) without having to abuse the underlying
net.Socket object.

This class does almost nothing, apart from holding internal references to
the net.Socket and SockhopServer instances, and is really intended to be
extended. As such, there are several 'virtual' methods included here,
which users are encouraged to implement for their specific application.

Sessions are the preferred way for users to interact with client connections,
in that users should write child classes which inhert from this base class to
interact with the net.Socket instance, and then have their applications call
the session methods, rather than calling socket methods directly. For instance,
users are discouraged from directly calling `socket.end()` to terminate
clients connection from the server. Rather, users should call `session.kill()`.

**Kind**: global class  
**Extends**: <code>EventEmitter</code>  

* [SockhopSession](#SockhopSession) ⇐ <code>EventEmitter</code>
    * [new SockhopSession(sock, server)](#new_SockhopSession_new)
    * [.sock](#SockhopSession+sock) : <code>net.Socket</code>
    * [.server](#SockhopSession+server) : [<code>SockhopServer</code>](#SockhopServer)
    * [.send(obj)](#SockhopSession+send) ⇒ <code>Promise</code>
    * [.request(obj, config)](#SockhopSession+request) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
    * [.kill()](#SockhopSession+kill) ⇒ <code>Promise</code>
    * *[.start()](#SockhopSession+start) ⇒ <code>Promise</code>*
    * *[.end()](#SockhopSession+end) ⇒ <code>Promise</code>*

<a name="new_SockhopSession_new"></a>

### new SockhopSession(sock, server)
Constructor

By default, I just save references to the socket and the server


| Param | Type | Description |
| --- | --- | --- |
| sock | <code>net.Socket</code> | the socket object |
| server | [<code>SockhopServer</code>](#SockhopServer) | a reference to the SockhopServer |

<a name="SockhopSession+sock"></a>

### sockhopSession.sock : <code>net.Socket</code>
Getter for the underlying session socket

**Kind**: instance property of [<code>SockhopSession</code>](#SockhopSession)  
<a name="SockhopSession+server"></a>

### sockhopSession.server : [<code>SockhopServer</code>](#SockhopServer)
Getter for the server

**Kind**: instance property of [<code>SockhopSession</code>](#SockhopSession)  
<a name="SockhopSession+send"></a>

### sockhopSession.send(obj) ⇒ <code>Promise</code>
Send a message over this session

**Kind**: instance method of [<code>SockhopSession</code>](#SockhopSession)  
**Returns**: <code>Promise</code> - resolves on send  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type |
| --- | --- |
| obj | <code>object</code> | 

<a name="SockhopSession+request"></a>

### sockhopSession.request(obj, config) ⇒ [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream)
Send a request over this session

**Kind**: instance method of [<code>SockhopSession</code>](#SockhopSession)  
**Returns**: [<code>Promise.&lt;SockhopResponseReadableStream&gt;</code>](#SockhopResponseReadableStream) - resolves to peer response  
**Throws**:

- [<code>SockhopError</code>](#SockhopError) 


| Param | Type |
| --- | --- |
| obj | <code>object</code> | 
| config | <code>object</code> | 

<a name="SockhopSession+kill"></a>

### sockhopSession.kill() ⇒ <code>Promise</code>
Kill this session

**Kind**: instance method of [<code>SockhopSession</code>](#SockhopSession)  
**Returns**: <code>Promise</code> - resolves on socket end  
<a name="SockhopSession+start"></a>

### *sockhopSession.start() ⇒ <code>Promise</code>*
Start this session

Override me to do any setup of the session.

I get called internally by the SockhopServer immediately after
a new client connects to the server, before the server emits the
'connect' event. (before even the socket gets registered in the
server's `server._sockets` list).

**Kind**: instance abstract method of [<code>SockhopSession</code>](#SockhopSession)  
**Returns**: <code>Promise</code> - resolves when setup is complete  
<a name="SockhopSession+end"></a>

### *sockhopSession.end() ⇒ <code>Promise</code>*
End this session

Override me to do any teardown of the session

I get called internally by the SockhopServer immediately after
the client's socket emits the 'end' event, and when I resolve, I
then trigger the server to emit the 'disconnect' event.

**Kind**: instance abstract method of [<code>SockhopSession</code>](#SockhopSession)  
**Returns**: <code>Promise</code> - resolves when teardown is complete  
<a name="TimedMap"></a>

## TimedMap
A timed map object

This is a wrapper around a map, which keeps a timer going to automatically
remove values that have been present for too long.

**Kind**: global class  

* [TimedMap](#TimedMap)
    * [new TimedMap([opts])](#new_TimedMap_new)
    * [.set(key, value, cb, [timeout])](#TimedMap+set)
    * [.get(key)](#TimedMap+get) ⇒ <code>\*</code>
    * [.delete(key)](#TimedMap+delete)
    * [.stop()](#TimedMap+stop)

<a name="new_TimedMap_new"></a>

### new TimedMap([opts])
Constructor


| Param | Type | Description |
| --- | --- | --- |
| [opts] | <code>object</code> | an object containing configuration options |
| [opts.timeout] | <code>number</code> | the length of time in ms that this map should hold values by default |

<a name="TimedMap+set"></a>

### timedMap.set(key, value, cb, [timeout])
Insert a new value

**Kind**: instance method of [<code>TimedMap</code>](#TimedMap)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>\*</code> |  |
| value | <code>\*</code> |  |
| cb | <code>function</code> | callback for when the value is returned, giving you the reason. Signature: `(reason) => {}` |
| [timeout] | <code>number</code> |  |

<a name="TimedMap+get"></a>

### timedMap.get(key) ⇒ <code>\*</code>
Get a value

**Kind**: instance method of [<code>TimedMap</code>](#TimedMap)  

| Param | Type |
| --- | --- |
| key | <code>\*</code> | 

<a name="TimedMap+delete"></a>

### timedMap.delete(key)
Remove a value, also trigger the callback

**Kind**: instance method of [<code>TimedMap</code>](#TimedMap)  

| Param | Type |
| --- | --- |
| key | <code>\*</code> | 

<a name="TimedMap+stop"></a>

### timedMap.stop()
Remove all values, also trigger the callback

**Kind**: instance method of [<code>TimedMap</code>](#TimedMap)  
<a name="ResponsePacketPayload"></a>

## ResponsePacketPayload : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type |
| --- | --- |
| data | <code>\*</code> | 
| type | <code>string</code> | 

